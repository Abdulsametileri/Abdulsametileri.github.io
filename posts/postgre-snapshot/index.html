<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How We Implement Debezium Style Initial Data (Snapshot) Progress in Our PostgreSQL CDC Library | Abdulsamet's Blog</title><meta name=keywords content="go,postgresql"><meta name=description content="Learn how to implement snapshot functionality in PostgreSQL CDC libraries using a coordinator/worker model with metadata tables for progress tracking."><meta name=author content="Theme PaperMod"><link rel=canonical href=https://abdulsametileri.github.io/posts/postgre-snapshot/><meta name=google-site-verification content="G-6KKCPG75GY"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://abdulsametileri.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://abdulsametileri.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://abdulsametileri.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://abdulsametileri.github.io/apple-touch-icon.png><link rel=mask-icon href=https://abdulsametileri.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://abdulsametileri.github.io/posts/postgre-snapshot/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><meta property="og:url" content="https://abdulsametileri.github.io/posts/postgre-snapshot/"><meta property="og:site_name" content="Abdulsamet's Blog"><meta property="og:title" content="How We Implement Debezium Style Initial Data (Snapshot) Progress in Our PostgreSQL CDC Library"><meta property="og:description" content="Learn how to implement snapshot functionality in PostgreSQL CDC libraries using a coordinator/worker model with metadata tables for progress tracking."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-30T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-30T00:00:00+00:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Postgresql"><meta property="og:image" content="https://abdulsametileri.github.io/images/papermod-cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://abdulsametileri.github.io/images/papermod-cover.png"><meta name=twitter:title content="How We Implement Debezium Style Initial Data (Snapshot) Progress in Our PostgreSQL CDC Library"><meta name=twitter:description content="Learn how to implement snapshot functionality in PostgreSQL CDC libraries using a coordinator/worker model with metadata tables for progress tracking."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://abdulsametileri.github.io/posts/"},{"@type":"ListItem","position":2,"name":"How We Implement Debezium Style Initial Data (Snapshot) Progress in Our PostgreSQL CDC Library","item":"https://abdulsametileri.github.io/posts/postgre-snapshot/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How We Implement Debezium Style Initial Data (Snapshot) Progress in Our PostgreSQL CDC Library","name":"How We Implement Debezium Style Initial Data (Snapshot) Progress in Our PostgreSQL CDC Library","description":"Learn how to implement snapshot functionality in PostgreSQL CDC libraries using a coordinator/worker model with metadata tables for progress tracking.","keywords":["go","postgresql"],"articleBody":"In this article, weâ€™ll look at how we implemented snapshot mode in our go-pq-cdc PostgreSQL CDC library, and how it works under the hood.\nWhat is go-pq-cdc? go-pq-cdc is our PostgreSQL CDC (Change Data Capture) library. It is built on top of PostgreSQLâ€™s logical replication protocol. Itâ€™s a Debezium alternative but in a better way in terms of resource consumption and performance benchmarks.\nThe CDC part of this library has been running in production for over a year. Thanks to Serhat Karabulut. He wrote this project and provided significant support throughout the entire process.\nPostgreSQL to Kafka and Elasticsearch connectors are also available and used in production.\nBefore we dive into the snapshot feature, letâ€™s briefly cover a few key PostgreSQL concepts.\nWhat is logical replication? Logical replication is a method of replicating data objects and their changes, based upon their replication identity (usually a primary key). It uses a publish-subscribe model.\nPublication Publication is a set of changes (insert, update, delete, truncate) generated from a table or a group of tables.\npublication.Config{ Name: \"cdc_publication\", Operations: publication.Operations{ publication.OperationInsert, publication.OperationDelete, publication.OperationTruncate, publication.OperationUpdate, }, Tables: publication.Tables{ publication.Table{ Name: \"books\", ReplicaIdentity: publication.ReplicaIdentityDefault, Schema: \"public\", }, publication.Table{ Name: \"users\", ReplicaIdentity: publication.ReplicaIdentityFull, Schema: \"public\", }, }, } We mentioned that a publication is a set of operations. But how do we identify which rows were updated or deleted? This is where Replication Identity comes into play.\nBy default, this is the primary key, if there is one. If the table doesnâ€™t have a suitable key, then the entire row becomes the key. In our library, we support two replication identity options:\nReplicaIdentityOptions = []string{ReplicaIdentityDefault, ReplicaIdentityFull} ReplicaIdentityMap = map[string]string{ \"d\": ReplicaIdentityDefault, // primary key \"f\": ReplicaIdentityFull, // full row } Replication Slot Replication Slot is a server-side object that tracks a replicaâ€™s progress and retains WAL files to prevent them from being deleted before the replica has consumed them. This concept existed before logical replication was introduced, but itâ€™s also used in logical replication.\nIn the logical replication context, a replication slot holds the Log Sequence Number (LSN)â€”a position in the transaction log (WAL/XLOG). Every time the subscriber successfully receives and processes data, the slotâ€™s LSN is advanced. This ensures no data loss and enables accurate restart from the last processed position.\nHereâ€™s how you configure a replication slot in go-pq-cdc:\nSlot: slot.Config{ Name: \"cdc_slot\" } There is a library-specific config slot.slotActivityCheckerInterval that continuously tracks the slot activity. If the replication slot becomes inactive, go-pq-cdc automatically reclaims the slot and resumes data capturing for high availability.\nHow it is used in go-pq-cdc? Full example here.\nConfiguration First, set up the configuration with publication, slot, and other settings:\ncfg := config.Config{ // PostgreSQL connection credentials (Host, Port, User, Password, Database) Publication: publication.Config{ CreateIfNotExists: true, Name: \"cdc_publication\", Operations: publication.Operations{ publication.OperationInsert, publication.OperationDelete, publication.OperationTruncate, publication.OperationUpdate, }, Tables: publication.Tables{ publication.Table{ Name: \"users\", ReplicaIdentity: publication.ReplicaIdentityDefault, Schema: \"public\", }, }, }, Slot: slot.Config{ CreateIfNotExists: true, Name: \"cdc_slot\", }, Metric: config.MetricConfig{ Port: 8081, }, Logger: config.LoggerConfig{ LogLevel: slog.LevelInfo, }, } connector, err := cdc.NewConnector(ctx, cfg, Handler) if err != nil { slog.Error(\"new connector\", \"error\", err) os.Exit(1) } defer connector.Close() connector.Start(ctx) Handler Function Subscribe to changes by providing a handler function that processes different message types:\nfunc Handler(ctx *replication.ListenerContext) { switch msg := ctx.Message.(type) { case *format.Insert: slog.Info(\"insert message received\", \"new\", msg.Decoded) case *format.Delete: slog.Info(\"delete message received\", \"old\", msg.OldDecoded) case *format.Update: slog.Info(\"update message received\", \"new\", msg.NewDecoded, \"old\", msg.OldDecoded) } if err := ctx.Ack(); err != nil { slog.Error(\"ack\", \"error\", err) } } By calling ctx.Ack(), we signal that weâ€™ve processed this message and the WAL LSN position should be advanced. Thereâ€™s no need to keep that message change anymore in the wal segment.\nSnapshot Feature In database terminology, a snapshot refers to a copy of a database (or table in a database) that is taken at a particular point in timeâ€”just like taking a snapshot with a camera (From Streaming Databases Book).\nWhy Do We Need a Snapshot? The Snapshot Feature enables initial data capture from PostgreSQL tables before starting Change Data Capture (CDC). This ensures that your downstream systems receive both:\nExisting data (via snapshot) Real-time changes (via CDC) Without snapshot support, CDC only captures changes that occur after the replication slot is created, missing all pre-existing data.\nConsider this scenario:\nTimeline: T0: Table \"users\" has 1M rows T1: You start go-pq-cdc (CDC only) T2: 10 new rows inserted Result: You only get 10 rows, missing the initial 1M rows! âŒ With snapshot enabled:\nTimeline: T0: Table \"users\" has 1M rows T1: You start go-pq-cdc with snapshot enabled - Snapshot captures 1M rows at LSN=X - Replication slot created at LSN=X or LSN= X) T3: Snapshot completes, CDC starts from LSN=X - CDC captures the 10 new rows Result: You get all 1M + 10 rows, with no duplicates! In other words, pure CDC alone can never give you the historical state of the table; it only tells you what changed after you started.\nThere are three snapshot mode options available:\ninitial Take a snapshot once (only if no previous snapshot exists), then continue with CDC from that point. snapshot_only: Take a snapshot and then exit. No CDC and no publication/replication slot are used. never: Do not take a snapshot; start CDC immediately from the replication slotâ€™s position. (default) Internally, the snapshot process uses a coordinator/worker model and two metadata tables to track progress. We will get into the details later.\nLetâ€™s see how itâ€™s used first.\nQuick Start (How to Use Snapshot in go-pq-cdc) Enable snapshot: Set snapshot.enabled = true and choose a mode (initial, snapshot_only, or never). Configure tables: Use publication.tables (for initial) or snapshot.tables (for snapshot_only) to list the tables you want. Handle events: In your handler, process *format.Snapshot events (Begin, Data, End) alongside normal CDC events. CDC continuation: In initial mode, once snapshot is done, CDC automatically continues from the captured LSN â€” no gaps, no duplicates. How snapshot mode â€˜Initialâ€™ is used Full example here.\nWe have users table. 1000 users exist.\nConfiguration cfg := config.Config{ // PostgreSQL connection credentials (Host, Port, User, Password, Database) Publication: publication.Config{ CreateIfNotExists: true, Name: \"cdc_publication\", Operations: publication.Operations{ publication.OperationInsert, publication.OperationDelete, publication.OperationTruncate, publication.OperationUpdate, }, Tables: publication.Tables{ publication.Table{ Name: \"users\", ReplicaIdentity: publication.ReplicaIdentityDefault, Schema: \"public\", }, }, }, Slot: slot.Config{ CreateIfNotExists: true, Name: \"cdc_slot\", }, Snapshot: config.SnapshotConfig{ // -- NEWLY ADDED! Enabled: true, Mode: config.SnapshotModeInitial, ChunkSize: 100, ClaimTimeout: 30 * time.Second, HeartbeatInterval: 5 * time.Second, } Metric: config.MetricConfig{ Port: 8081, }, Logger: config.LoggerConfig{ LogLevel: slog.LevelInfo, }, } connector, err := cdc.NewConnector(ctx, cfg, Handler) if err != nil { slog.Error(\"new connector\", \"error\", err) os.Exit(1) } defer connector.Close() connector.Start(ctx) Handler Function Subscribe to snapshot and changes by providing a handler function that processes different message types:\nfunc Handler(ctx *replication.ListenerContext) { switch msg := ctx.Message.(type) { case *format.Insert: slog.Info(\"insert message received\", \"new\", msg.Decoded) case *format.Delete: slog.Info(\"delete message received\", \"old\", msg.OldDecoded) case *format.Update: slog.Info(\"update message received\", \"new\", msg.NewDecoded, \"old\", msg.OldDecoded) case *format.Snapshot: handleSnapshot(msg) } if err := ctx.Ack(); err != nil { slog.Error(\"ack\", \"error\", err) } } func handleSnapshot(s *format.Snapshot) { switch s.EventType { case format.SnapshotEventTypeBegin: log.Printf(\"ğŸ“¸ SNAPSHOT BEGIN | LSN: %s | Time: %s\", s.LSN.String(), s.ServerTime.Format(\"15:04:05\")) case format.SnapshotEventTypeData: slog.Info(\"snapshot message received\", \"data\", s.Data) case format.SnapshotEventTypeEnd: log.Printf(\"ğŸ“¸ SNAPSHOT END | LSN: %s | Time: %s\", s.LSN.String(), s.ServerTime.Format(\"15:04:05\")) } } We expose explicit snapshot begin and end markers so that consumers can control how they handle the snapshot window.\nNote: Snapshot messages are not tied to WAL positions, so ctx.Ack() is a noâ€‘op and always returns nil during snapshot.\nMonitoring There are two metadata tables.\ncdc_snapshot_job: Metadata table for snapshot process tracking cdc_snapshot_chunks: Each chunk represents work to be done chunk_start and chunk_end: Used for non-numeric primary keys with LIMIT/OFFSET queries range_start and range_end: Used for numeric primary keys with range-based WHERE clauses for better performance Range scanning on a numeric PK is not only faster than LIMIT/OFFSET but also avoids performance degradation as the offset grows.\nfunc (s *Snapshotter) buildChunkQuery(chunk *Chunk, orderByClause string, pkColumns []string) string { if chunk.hasRangeBounds() \u0026\u0026 len(pkColumns) == 1 { pkColumn := pkColumns[0] return fmt.Sprintf( \"SELECT * FROM %s.%s WHERE %s \u003e= %d AND %s \u003c= %d ORDER BY %s LIMIT %d\", chunk.TableSchema, chunk.TableName, pkColumn, *chunk.RangeStart, pkColumn, *chunk.RangeEnd, orderByClause, chunk.ChunkSize, ) } return fmt.Sprintf( \"SELECT * FROM %s.%s ORDER BY %s LIMIT %d OFFSET %d\", chunk.TableSchema, chunk.TableName, orderByClause, chunk.ChunkSize, chunk.ChunkStart, ) } Currently we only use range bounds when there is a single numeric primary key; composite keys fall back to LIMIT/OFFSET chunking.\nclaimed_by: Shows which instance is responsible for that chunk claimed_at: Shows when the instance was assigned to the chunk heartbeat_at: Instance heartbeat updates, so we can determine if itâ€™s alive or not. If the heartbeat stops, after claimTimeout passes, the chunk is released and a new instance is assigned. You can control this via Snapshot: config.SnapshotConfig{ ... ClaimTimeout: 30 * time.Second, \u003c-- timeout to reclaim stale chunks HeartbeatInterval: 5 * time.Second, \u003c-- heartbeat at every 5 sec } How snapshot mode â€˜Snapshot Onlyâ€™ is used Full example here.\nWe have users table. 100 users exist.\nConfiguration Note: No need to provide slot or publication configuration for snapshot-only mode cfg := config.Config{ // PostgreSQL connection credentials (Host, Port, User, Password, Database) Snapshot: config.SnapshotConfig{ Enabled: true, Mode: config.SnapshotModeSnapshotOnly, Tables: publication.Tables{ // --\u003e Snapshot tables publication.Table{ Name: \"users\", ReplicaIdentity: publication.ReplicaIdentityDefault, Schema: \"public\", }, }, ChunkSize: 100, ClaimTimeout: 30 * time.Second, HeartbeatInterval: 5 * time.Second, } Metric: config.MetricConfig{ Port: 8081, }, Logger: config.LoggerConfig{ LogLevel: slog.LevelInfo, }, } connector, err := cdc.NewConnector(ctx, cfg, Handler) if err != nil { slog.Error(\"new connector\", \"error\", err) os.Exit(1) } defer connector.Close() connector.Start(ctx) Handler Function Subscribe to snapshot messages by providing a handler function:\nfunc Handler(ctx *replication.ListenerContext) { msg := ctx.Message.(*format.Snapshot) switch msg.EventType { case format.SnapshotEventTypeBegin: log.Printf(\"ğŸ“¸ SNAPSHOT BEGIN | LSN: %s | Time: %s\", msg.LSN.String(), msg.ServerTime.Format(\"15:04:05\")) case format.SnapshotEventTypeData: slog.Info(\"snapshot message received\", \"data\", msg.Data) case format.SnapshotEventTypeEnd: log.Printf(\"ğŸ“¸ SNAPSHOT END | LSN: %s | Time: %s\", msg.LSN.String(), msg.ServerTime.Format(\"15:04:05\")) } } Scaling Snapshot Process We can easily scale horizontally during the snapshot process.\nFull example here.\nThere is no specific configuration or handling required in the codebase for scaling.\nLetâ€™s play with it by scaling to 3 containers docker-compose up --scale go-pq-cdc=3 -d\nSnapshot Architecture Basics (How It Works Internally) The rest of this article explains how we implemented snapshotting under the hood. You donâ€™t need this part to use the feature, but itâ€™s useful if you care about the internals or want to adapt the design.\nBefore we walk through the snapshot lifecycle, we need to explain a couple of concepts.\npg_try_advisory_lock() pg_try_advisory_lock is a non-blocking function in PostgreSQL. It attempts to acquire an application-level lock using a key you specify. If the lock is already held by another session (in our case instance), the function returns FALSE immediately instead of waiting.\nlockID := hashString(slotName) // e.g., \"cdc_slot\" -\u003e 12345 acquired := SELECT pg_try_advisory_lock(lockID) When multiple instances start simultaneously, they need to elect a coordinator:\nCoordinator Election â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚Instance1â”‚â”€â”€pg_try_advisory_lock()â”€â”€â–º Success (Coordinator) â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚Instance2â”‚â”€â”€pg_try_advisory_lock()â”€â”€â–º Fail (Worker) â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚Instance3â”‚â”€â”€pg_try_advisory_lock()â”€â”€â–º Fail (Worker) â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Advisory locks are automatically released when the connection closes. If you are using PgBouncer, prefer transaction pooling mode here; session mode may cause surprising behavior with advisory locks because connections are reused across sessions.\nRepeatable Read Isolation Level The Repeatable Read isolation level guarantees that any rows a transaction reads will remain unchanged for the duration of that transaction, preventing non-repeatable reads. Letâ€™s examine it with an example.\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Time â”‚ Transaction A (Repeatable Read) â”‚ Transaction B (Normal) â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ T1 â”‚ BEGIN TRANSACTION ISOLATION â”‚ â”‚ â”‚ â”‚ LEVEL REPEATABLE READ; â”‚ â”‚ â”‚ â”‚ â†’ Takes snapshot of data â”‚ â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ T2 â”‚ SELECT balance FROM Accounts â”‚ â”‚ â”‚ â”‚ WHERE AccountID = 1; â”‚ â”‚ â”‚ â”‚ â†’ Result: 500 â‚º â”‚ â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ T3 â”‚ â”‚ BEGIN TRANSACTION; â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ T4 â”‚ â”‚ UPDATE Accounts SET balance = 400 â”‚ â”‚ â”‚ â”‚ WHERE AccountID = 1; â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ T5 â”‚ â”‚ COMMIT; âœ“ â”‚ â”‚ â”‚ â”‚ â†’ 400 â‚º is now permanent â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ T6 â”‚ SELECT balance FROM Accounts â”‚ â”‚ â”‚ â”‚ WHERE AccountID = 1; â”‚ â”‚ â”‚ â”‚ â†’ Result: 500 â‚º (still!) â”‚ â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ T7 â”‚ COMMIT; â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Key Point: Transaction A always reads from the data as it was at T1, regardless of Bâ€™s commit at T5. This is how we ensure all instances read a consistent, frozen view of the data during the entire snapshot.\nIn our library, the coordinator exports a PostgreSQL snapshot and keeps it open during the snapshot process:\n// 1. Start transaction (REPEATABLE READ for consistency) BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ // 2. Export snapshot snapshotID := SELECT pg_export_snapshot() // Returns: \"00000003-00000002-1\" // 3. Keep transaction OPEN! // (Do NOT commit/rollback yet) // 4. Update job metadata UPDATE cdc_snapshot_job SET snapshot_id = '00000003-00000002-1' WHERE slot_name = 'cdc_slot' Why? Because when we are using multiple instances, we need to ensure that all instances see same snapshot of the data.\nBy exporting the coordinator transactionâ€™s snapshot using pg_export_snapshot(), workers can read this value from cdc_snapshot_job and set their own transactions to it, so we provide transactional consistency.\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Coordinator Transaction (REPEATABLE READ) â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ BEGIN â”‚ â”‚ â”‚ â”‚ SELECT pg_export_snapshot() â†’ 'snapshot_123' â”‚ â”‚ â”‚ â”‚ ... (transaction stays open) ... â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ â”‚ â”‚ Worker 1: SET TRANSACTION SNAPSHOT 'snap123' â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ SELECT * FROM users ... (sees same data!) â”‚ â”‚ â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ â”‚ â”‚ Worker 2: SET TRANSACTION SNAPSHOT 'snap123' â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ SELECT * FROM orders ... (sees same data!) â”‚ â”‚ â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ COMMIT (after all chunks done) â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ If coordinator closed transaction early: âŒ Snapshot ID becomes invalid âŒ Workers can't use SET TRANSACTION SNAPSHOT âŒ Data inconsistency across chunks âŒ All snapshot process is aborted. It will start to take new snapshot! Because the coordinator holds a longâ€‘running REPEATABLE READ transaction, old row versions must be kept until the snapshot finishes. For most initialâ€‘load scenarios this is acceptable, but you should be aware of the potential for extra bloat while a long snapshot is running.\nHow We Ensure No Data Is Missed How do we ensure no data is missed between snapshot and CDC process?\nBefore starting the snapshot, we capture the current LSN with pg_current_wal_lsn().\nThe single value returned by SELECT pg_current_wal_lsn() represents the absolute location of the last point the primary server has written to the Write-Ahead Log (WAL).\nWe use this value as the starting LSN when we start the replication slot stream:\nSTART_REPLICATION SLOT cdc_slot LOGICAL 0/12345678\nTimeline: â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ â”‚ â”‚ T0 T1 T2 Snapshot LSN Snapshot End Current Time (0/12345678) â”‚ â”‚ â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ Snapshot Data â”‚ CDC Data â”‚ â”‚ (goes to handler)â”‚ (goes to handler) â”‚ â”‚ â”‚ â”‚ â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ No overlap! CDC starts from snapshot LSN Simply, all rows selected during snapshot are guaranteed to be visible as of the snapshotâ€™s MVCC view; any later changes will appear as logical replication events after we start CDC at the stored LSN.\nSnapshot Lifecycle The snapshot process consists of 5 phases:\nPhase 1: Coordinator Election Instance1 â”€â”€pg_try_advisory_lock()â”€â”€â–º Success (Coordinator) âœ“ Instance2 â”€â”€pg_try_advisory_lock()â”€â”€â–º Fail (Worker) Instance3 â”€â”€pg_try_advisory_lock()â”€â”€â–º Fail (Worker) Only one instance becomes the coordinator. Others become workers.\nPhase 2: Metadata Creation (Coordinator Only) -- Capture current LSN SELECT pg_current_wal_lsn(); -- â†’ 0/12345678 -- Create job metadata INSERT INTO cdc_snapshot_job (...); -- Split tables into chunks -- Table \"users\": 1M rows â†’ 10 chunks (100K each) INSERT INTO cdc_snapshot_chunks (...); Phase 3: Snapshot Export (Coordinator Only) BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ; SELECT pg_export_snapshot(); -- â†’ \"00000003-00000002-1\" -- Keep transaction OPEN! (critical) UPDATE cdc_snapshot_job SET snapshot_id = '00000003-00000002-1'; -- Workers can now join using this snapshot_id After that, the coordinator simply acts as another worker.\nPhase 4: Chunk Processing (All Instances in Parallel) Worker Loop: â”Œâ”€â–º Claim next chunk (SELECT FOR UPDATE SKIP LOCKED) â”‚ â”œâ”€â–º BEGIN TRANSACTION â”‚ â”œâ”€â–º SET TRANSACTION SNAPSHOT 'snapshot_id' â”‚ â”œâ”€â–º SELECT * FROM table WHERE id \u003e= X AND id \u003c= Y â”‚ â”œâ”€â–º Send DATA events to handler â”‚ â”œâ”€â–º COMMIT â”‚ â”œâ”€â–º Mark chunk completed â””â”€â”€â”€â”´â”€â”€ Repeat until no chunks left Phase 5: CDC Continuation All chunks completed â†’ Snapshot transaction closed CDC starts from snapshot LSN (START_REPLICATION SLOT ... LOGICAL 0/12345678) No duplicate data! Snapshot ends where CDC begins. Crash Recovery What happens if an instance crashes during snapshot?\nWorker Crash: The chunk being processed becomes â€œstaleâ€ after claimTimeout (e.g., 30s). Another instance automatically reclaims and reprocesses it.\nBefore Crash: C0: completed âœ“ C3: pending C1: completed âœ“ C4: pending C2: in_progress â† crashed here After Restart (30s later): C2 becomes stale â†’ reclaimed by healthy instance Coordinator Crash Before Export: Incomplete job is detected on restart. The system cleans up and restarts snapshot from scratch.\nWhen a worker (or a new instance) comes back, processing resumes from where it left off â€” completed chunks are skipped, pending chunks are processed.\nSummary The Snapshot Feature provides a robust, scalable solution for initial data capture:\nâœ… Zero Data Loss: Consistent snapshot + CDC continuation âœ… Scalable: Chunk-based, multi-instance parallel processing âœ… Resilient: Automatic crash recovery âœ… Observable: Metadata tables for progress tracking For more details, check out the go-pq-cdc repository.\nThank you for reading!\n","wordCount":"2926","inLanguage":"en","image":"https://abdulsametileri.github.io/images/papermod-cover.png","datePublished":"2025-11-30T00:00:00Z","dateModified":"2025-11-30T00:00:00Z","author":{"@type":"Person","name":"Theme PaperMod"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://abdulsametileri.github.io/posts/postgre-snapshot/"},"publisher":{"@type":"Organization","name":"Abdulsamet's Blog","logo":{"@type":"ImageObject","url":"https://abdulsametileri.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://abdulsametileri.github.io/ accesskey=h title="Abdulsamet's Blog (Alt + H)">Abdulsamet's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://abdulsametileri.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://abdulsametileri.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://abdulsametileri.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://abdulsametileri.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://abdulsametileri.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">How We Implement Debezium Style Initial Data (Snapshot) Progress in Our PostgreSQL CDC Library</h1><div class=post-description>Learn how to implement snapshot functionality in PostgreSQL CDC libraries using a coordinator/worker model with metadata tables for progress tracking.</div><div class=post-meta><span title='2025-11-30 00:00:00 +0000 UTC'>November 30, 2025</span>&nbsp;Â·&nbsp;<span>14 min</span>&nbsp;Â·&nbsp;<span>2926 words</span>&nbsp;Â·&nbsp;<span>Theme PaperMod</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-is-go-pq-cdc aria-label="What is go-pq-cdc?">What is go-pq-cdc?</a></li><li><a href=#what-is-logical-replication aria-label="What is logical replication?">What is logical replication?</a></li><li><a href=#publication aria-label=Publication>Publication</a></li><li><a href=#replication-slot aria-label="Replication Slot">Replication Slot</a></li><li><a href=#how-it-is-used-in-go-pq-cdc aria-label="How it is used in go-pq-cdc?">How it is used in go-pq-cdc?</a><ul><li><a href=#configuration aria-label=Configuration>Configuration</a><ul><li><a href=#handler-function aria-label="Handler Function">Handler Function</a></li></ul></li></ul></li><li><a href=#snapshot-feature aria-label="Snapshot Feature">Snapshot Feature</a><ul><li><a href=#why-do-we-need-a-snapshot aria-label="Why Do We Need a Snapshot?">Why Do We Need a Snapshot?</a></li><li><a href=#quick-start-how-to-use-snapshot-in-go-pq-cdc aria-label="Quick Start (How to Use Snapshot in go-pq-cdc)">Quick Start (How to Use Snapshot in go-pq-cdc)</a></li><li><a href=#how-snapshot-mode-initial-is-used aria-label="How snapshot mode &lsquo;Initial&rsquo; is used">How snapshot mode &lsquo;Initial&rsquo; is used</a><ul><li><a href=#configuration-1 aria-label=Configuration>Configuration</a></li><li><a href=#handler-function-1 aria-label="Handler Function">Handler Function</a></li></ul></li><li><a href=#monitoring aria-label=Monitoring>Monitoring</a></li><li><a href=#how-snapshot-mode-snapshot-only-is-used aria-label="How snapshot mode &lsquo;Snapshot Only&rsquo; is used">How snapshot mode &lsquo;Snapshot Only&rsquo; is used</a><ul><li><a href=#configuration-2 aria-label=Configuration>Configuration</a></li><li><a href=#handler-function-2 aria-label="Handler Function">Handler Function</a></li></ul></li><li><a href=#scaling-snapshot-process aria-label="Scaling Snapshot Process">Scaling Snapshot Process</a></li></ul></li><li><a href=#snapshot-architecture-basics-how-it-works-internally aria-label="Snapshot Architecture Basics (How It Works Internally)">Snapshot Architecture Basics (How It Works Internally)</a><ul><li><a href=#pg_try_advisory_lock aria-label=pg_try_advisory_lock()>pg_try_advisory_lock()</a></li><li><a href=#repeatable-read-isolation-level aria-label="Repeatable Read Isolation Level">Repeatable Read Isolation Level</a></li><li><a href=#how-we-ensure-no-data-is-missed aria-label="How We Ensure No Data Is Missed">How We Ensure No Data Is Missed</a></li></ul></li><li><a href=#snapshot-lifecycle aria-label="Snapshot Lifecycle">Snapshot Lifecycle</a><ul><li><a href=#phase-1-coordinator-election aria-label="Phase 1: Coordinator Election">Phase 1: Coordinator Election</a></li><li><a href=#phase-2-metadata-creation-coordinator-only aria-label="Phase 2: Metadata Creation (Coordinator Only)">Phase 2: Metadata Creation (Coordinator Only)</a></li><li><a href=#phase-3-snapshot-export-coordinator-only aria-label="Phase 3: Snapshot Export (Coordinator Only)">Phase 3: Snapshot Export (Coordinator Only)</a></li><li><a href=#phase-4-chunk-processing-all-instances-in-parallel aria-label="Phase 4: Chunk Processing (All Instances in Parallel)">Phase 4: Chunk Processing (All Instances in Parallel)</a></li><li><a href=#phase-5-cdc-continuation aria-label="Phase 5: CDC Continuation">Phase 5: CDC Continuation</a></li><li><a href=#crash-recovery aria-label="Crash Recovery">Crash Recovery</a></li></ul></li><li><a href=#summary aria-label=Summary>Summary</a></li></ul></div></details></div><div class=post-content><p>In this article, weâ€™ll look at how we implemented snapshot mode in our <a href=https://github.com/Trendyol/go-pq-cdc>go-pq-cdc</a> PostgreSQL CDC library, and how it works under the hood.</p><h2 id=what-is-go-pq-cdc>What is go-pq-cdc?<a hidden class=anchor aria-hidden=true href=#what-is-go-pq-cdc>#</a></h2><ul><li><p><a href=https://github.com/Trendyol/go-pq-cdc>go-pq-cdc</a> is our PostgreSQL CDC <em>(Change Data Capture)</em> library. It is built on top of <a href=https://www.postgresql.org/docs/current/logical-replication.html>PostgreSQL&rsquo;s logical replication protocol</a>. It&rsquo;s a <a href=https://debezium.io/>Debezium</a> alternative but in a better way in terms of resource consumption and performance <a href=https://github.com/Trendyol/go-pq-cdc/tree/main/benchmark>benchmarks</a>.</p></li><li><p>The CDC part of this library has been running in production for over a year. Thanks to <a href=https://www.linkedin.com/in/serhat-karabulut/>Serhat Karabulut</a>. He wrote this project and provided significant support throughout the entire process.</p></li><li><p>PostgreSQL to <a href=https://github.com/Trendyol/go-pq-cdc-kafka>Kafka</a> and <a href=https://github.com/Trendyol/go-pq-cdc-elasticsearch>Elasticsearch</a> connectors are also available and used in production.</p></li></ul><blockquote><p>Before we dive into the snapshot feature, letâ€™s briefly cover a few key PostgreSQL concepts.</p></blockquote><h2 id=what-is-logical-replication>What is logical replication?<a hidden class=anchor aria-hidden=true href=#what-is-logical-replication>#</a></h2><blockquote><p><a href=https://www.postgresql.org/docs/current/logical-replication.html>Logical replication</a> is a method of replicating data objects and their changes, based upon their replication identity (usually a primary key). It uses a publish-subscribe model.</p></blockquote><h2 id=publication>Publication<a hidden class=anchor aria-hidden=true href=#publication>#</a></h2><ul><li><p><a href=https://www.postgresql.org/docs/current/logical-replication-publication.html#LOGICAL-REPLICATION-PUBLICATION>Publication</a> is a set of <strong>changes</strong> <em>(insert, update, delete, truncate)</em> generated from a table or a group of tables.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Name</span>:              <span style=color:#e6db74>&#34;cdc_publication&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Operations</span>: <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Operations</span>{
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>OperationInsert</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>OperationDelete</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>OperationTruncate</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>OperationUpdate</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Tables</span>: <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Tables</span>{
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Table</span>{
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>Name</span>:            <span style=color:#e6db74>&#34;books&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>ReplicaIdentity</span>: <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>ReplicaIdentityDefault</span>,
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>Schema</span>:          <span style=color:#e6db74>&#34;public&#34;</span>,
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Table</span>{
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>Name</span>:            <span style=color:#e6db74>&#34;users&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>ReplicaIdentity</span>: <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>ReplicaIdentityFull</span>,
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>Schema</span>:          <span style=color:#e6db74>&#34;public&#34;</span>,
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><p>We mentioned that a publication is a set of operations. But how do we identify which rows were updated or deleted? This is where <a href=https://www.postgresql.org/docs/current/logical-replication-publication.html#LOGICAL-REPLICATION-PUBLICATION-REPLICA-IDENTITY><code>Replication Identity</code></a> comes into play.</p><ul><li>By default, this is the primary key, if there is one.</li><li>If the table doesn&rsquo;t have a suitable key, then the entire row becomes the key.</li></ul><p>In our library, we support two replication identity options:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>ReplicaIdentityOptions</span> = []<span style=color:#66d9ef>string</span>{<span style=color:#a6e22e>ReplicaIdentityDefault</span>, <span style=color:#a6e22e>ReplicaIdentityFull</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>ReplicaIdentityMap</span>     = <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>{
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;d&#34;</span>: <span style=color:#a6e22e>ReplicaIdentityDefault</span>, <span style=color:#75715e>// primary key</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;f&#34;</span>: <span style=color:#a6e22e>ReplicaIdentityFull</span>,    <span style=color:#75715e>// full row</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=replication-slot>Replication Slot<a hidden class=anchor aria-hidden=true href=#replication-slot>#</a></h2><ul><li><p><a href=https://www.postgresql.org/docs/current/warm-standby.html#STREAMING-REPLICATION-SLOTS>Replication Slot</a> is a server-side object that tracks a replica&rsquo;s progress and <strong>retains WAL files</strong> to prevent them from being deleted before the replica has consumed them. This concept existed before logical replication was introduced, but it&rsquo;s also used in logical replication.</p></li><li><p>In the logical replication context, a replication slot holds the <a href=https://www.postgresql.org/docs/18/datatype-pg-lsn.html>Log Sequence Number (LSN)</a>â€”a position in the transaction log (WAL/XLOG). Every time the subscriber successfully receives and processes data, the slot&rsquo;s LSN is advanced. This ensures no data loss and enables accurate restart from the last processed position.</p></li></ul><p>Here&rsquo;s how you configure a replication slot in go-pq-cdc:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>Slot</span>: <span style=color:#a6e22e>slot</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Name</span>:  <span style=color:#e6db74>&#34;cdc_slot&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>There is a library-specific config <code>slot.slotActivityCheckerInterval</code> that continuously tracks the slot activity. If the replication slot becomes inactive, go-pq-cdc automatically reclaims the slot and resumes data capturing for high availability.</p></blockquote><h2 id=how-it-is-used-in-go-pq-cdc>How it is used in go-pq-cdc?<a hidden class=anchor aria-hidden=true href=#how-it-is-used-in-go-pq-cdc>#</a></h2><p>Full example <a href=https://github.com/Trendyol/go-pq-cdc/tree/main/example/simple>here</a>.</p><h3 id=configuration>Configuration<a hidden class=anchor aria-hidden=true href=#configuration>#</a></h3><p>First, set up the configuration with publication, slot, and other settings:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>cfg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// PostgreSQL connection credentials (Host, Port, User, Password, Database)</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Publication</span>: <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CreateIfNotExists</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Name</span>:              <span style=color:#e6db74>&#34;cdc_publication&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Operations</span>: <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Operations</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>OperationInsert</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>OperationDelete</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>OperationTruncate</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>OperationUpdate</span>,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Tables</span>: <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Tables</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Table</span>{
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>Name</span>:            <span style=color:#e6db74>&#34;users&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>ReplicaIdentity</span>: <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>ReplicaIdentityDefault</span>,
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>Schema</span>:          <span style=color:#e6db74>&#34;public&#34;</span>,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Slot</span>: <span style=color:#a6e22e>slot</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CreateIfNotExists</span>:           <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Name</span>:                        <span style=color:#e6db74>&#34;cdc_slot&#34;</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Metric</span>: <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>MetricConfig</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Port</span>: <span style=color:#ae81ff>8081</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Logger</span>: <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>LoggerConfig</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LogLevel</span>: <span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>LevelInfo</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>connector</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cdc</span>.<span style=color:#a6e22e>NewConnector</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cfg</span>, <span style=color:#a6e22e>Handler</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#e6db74>&#34;new connector&#34;</span>, <span style=color:#e6db74>&#34;error&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>connector</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>connector</span>.<span style=color:#a6e22e>Start</span>(<span style=color:#a6e22e>ctx</span>)
</span></span></code></pre></div><h4 id=handler-function>Handler Function<a hidden class=anchor aria-hidden=true href=#handler-function>#</a></h4><p>Subscribe to changes by providing a handler function that processes different message types:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Handler</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>replication</span>.<span style=color:#a6e22e>ListenerContext</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>msg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Message</span>.(<span style=color:#66d9ef>type</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>Insert</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Info</span>(<span style=color:#e6db74>&#34;insert message received&#34;</span>, <span style=color:#e6db74>&#34;new&#34;</span>, <span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>Decoded</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>Delete</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Info</span>(<span style=color:#e6db74>&#34;delete message received&#34;</span>, <span style=color:#e6db74>&#34;old&#34;</span>, <span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>OldDecoded</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>Update</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Info</span>(<span style=color:#e6db74>&#34;update message received&#34;</span>, <span style=color:#e6db74>&#34;new&#34;</span>, <span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>NewDecoded</span>, <span style=color:#e6db74>&#34;old&#34;</span>, <span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>OldDecoded</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Ack</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#e6db74>&#34;ack&#34;</span>, <span style=color:#e6db74>&#34;error&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>By calling <code>ctx.Ack()</code>, we signal that we&rsquo;ve processed this message and the WAL LSN position should be advanced. There&rsquo;s no need to keep that message change anymore in the wal segment.</p></blockquote><h2 id=snapshot-feature>Snapshot Feature<a hidden class=anchor aria-hidden=true href=#snapshot-feature>#</a></h2><p>In database terminology, a snapshot refers to a copy of a database (or table in a database) that is taken at a particular point in timeâ€”just like taking a snapshot with a camera (<a href=https://www.oreilly.com/library/view/streaming-databases/9781098154820/>From Streaming Databases Book</a>).</p><h3 id=why-do-we-need-a-snapshot>Why Do We Need a Snapshot?<a hidden class=anchor aria-hidden=true href=#why-do-we-need-a-snapshot>#</a></h3><p>The <strong>Snapshot Feature</strong> enables <strong>initial data capture</strong> from PostgreSQL tables before starting Change Data Capture (CDC). This ensures that your downstream systems receive both:</p><ol><li><strong>Existing data</strong> (via snapshot)</li><li><strong>Real-time changes</strong> (via CDC)</li></ol><p>Without snapshot support, CDC only captures changes that occur <strong>after the replication slot is created</strong>, missing all pre-existing data.</p><p>Consider this scenario:</p><pre tabindex=0><code>Timeline:
  T0: Table &#34;users&#34; has 1M rows
  T1: You start go-pq-cdc (CDC only)
  T2: 10 new rows inserted
  
Result: You only get 10 rows, missing the initial 1M rows! âŒ
</code></pre><p>With snapshot enabled:</p><pre tabindex=0><code>Timeline:
  T0: Table &#34;users&#34; has 1M rows
  T1: You start go-pq-cdc with snapshot enabled
      - Snapshot captures 1M rows at LSN=X
      - Replication slot created at LSN=X or LSN=&lt;X
  T2: 10 new rows inserted (at LSN=Y, Y &gt; X)
  T3: Snapshot completes, CDC starts from LSN=X
      - CDC captures the 10 new rows
  
Result: You get all 1M + 10 rows, with no duplicates!
</code></pre><blockquote><p>In other words, pure CDC alone can never give you the historical state of the table; it only tells you what changed after you started.</p></blockquote><p>There are three snapshot mode options available:</p><ul><li><strong><code>initial</code></strong> Take a snapshot once (only if no previous snapshot exists), then continue with CDC from that point.</li><li><strong><code>snapshot_only</code></strong>: Take a snapshot and then exit. No CDC and no publication/replication slot are used.</li><li><strong><code>never</code></strong>: Do not take a snapshot; start CDC immediately from the replication slotâ€™s position. (default)</li></ul><p>Internally, the snapshot process uses a <strong>coordinator/worker</strong> model and <strong>two metadata tables</strong> to track progress. We will get into the details later.</p><p>Let&rsquo;s see how it&rsquo;s used first.</p><h3 id=quick-start-how-to-use-snapshot-in-go-pq-cdc>Quick Start (How to Use Snapshot in go-pq-cdc)<a hidden class=anchor aria-hidden=true href=#quick-start-how-to-use-snapshot-in-go-pq-cdc>#</a></h3><ul><li><strong>Enable snapshot</strong>: Set <code>snapshot.enabled = true</code> and choose a <code>mode</code> (<code>initial</code>, <code>snapshot_only</code>, or <code>never</code>).</li><li><strong>Configure tables</strong>: Use <code>publication.tables</code> (for <code>initial</code>) or <code>snapshot.tables</code> (for <code>snapshot_only</code>) to list the tables you want.</li><li><strong>Handle events</strong>: In your handler, process <code>*format.Snapshot</code> events (<code>Begin</code>, <code>Data</code>, <code>End</code>) alongside normal CDC events.</li><li><strong>CDC continuation</strong>: In <code>initial</code> mode, once snapshot is done, CDC automatically continues from the captured LSN â€” no gaps, no duplicates.</li></ul><h3 id=how-snapshot-mode-initial-is-used>How snapshot mode &lsquo;Initial&rsquo; is used<a hidden class=anchor aria-hidden=true href=#how-snapshot-mode-initial-is-used>#</a></h3><p>Full example <a href=https://github.com/Trendyol/go-pq-cdc/tree/main/example/snapshot-initial-mode>here</a>.</p><p>We have <code>users</code> table. <code>1000</code> users exist.</p><h4 id=configuration-1>Configuration<a hidden class=anchor aria-hidden=true href=#configuration-1>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>cfg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// PostgreSQL connection credentials (Host, Port, User, Password, Database)</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Publication</span>: <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CreateIfNotExists</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Name</span>:              <span style=color:#e6db74>&#34;cdc_publication&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Operations</span>: <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Operations</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>OperationInsert</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>OperationDelete</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>OperationTruncate</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>OperationUpdate</span>,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Tables</span>: <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Tables</span>{
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Table</span>{
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>Name</span>:            <span style=color:#e6db74>&#34;users&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>ReplicaIdentity</span>: <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>ReplicaIdentityDefault</span>,
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>Schema</span>:          <span style=color:#e6db74>&#34;public&#34;</span>,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Slot</span>: <span style=color:#a6e22e>slot</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>CreateIfNotExists</span>:           <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Name</span>:                        <span style=color:#e6db74>&#34;cdc_slot&#34;</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Snapshot</span>: <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>SnapshotConfig</span>{ <span style=color:#75715e>// -- NEWLY ADDED!</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Enabled</span>:           <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Mode</span>:              <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>SnapshotModeInitial</span>, 
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ChunkSize</span>:         <span style=color:#ae81ff>100</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ClaimTimeout</span>:      <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>HeartbeatInterval</span>: <span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Metric</span>: <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>MetricConfig</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Port</span>: <span style=color:#ae81ff>8081</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Logger</span>: <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>LoggerConfig</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LogLevel</span>: <span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>LevelInfo</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>connector</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cdc</span>.<span style=color:#a6e22e>NewConnector</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cfg</span>, <span style=color:#a6e22e>Handler</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#e6db74>&#34;new connector&#34;</span>, <span style=color:#e6db74>&#34;error&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>connector</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>connector</span>.<span style=color:#a6e22e>Start</span>(<span style=color:#a6e22e>ctx</span>)
</span></span></code></pre></div><h4 id=handler-function-1>Handler Function<a hidden class=anchor aria-hidden=true href=#handler-function-1>#</a></h4><p>Subscribe to snapshot and changes by providing a handler function that processes different message types:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Handler</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>replication</span>.<span style=color:#a6e22e>ListenerContext</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>msg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Message</span>.(<span style=color:#66d9ef>type</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>Insert</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Info</span>(<span style=color:#e6db74>&#34;insert message received&#34;</span>, <span style=color:#e6db74>&#34;new&#34;</span>, <span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>Decoded</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>Delete</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Info</span>(<span style=color:#e6db74>&#34;delete message received&#34;</span>, <span style=color:#e6db74>&#34;old&#34;</span>, <span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>OldDecoded</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>Update</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Info</span>(<span style=color:#e6db74>&#34;update message received&#34;</span>, <span style=color:#e6db74>&#34;new&#34;</span>, <span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>NewDecoded</span>, <span style=color:#e6db74>&#34;old&#34;</span>, <span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>OldDecoded</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>Snapshot</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>handleSnapshot</span>(<span style=color:#a6e22e>msg</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Ack</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#e6db74>&#34;ack&#34;</span>, <span style=color:#e6db74>&#34;error&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handleSnapshot</span>(<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>Snapshot</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>EventType</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>SnapshotEventTypeBegin</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;ğŸ“¸ SNAPSHOT BEGIN | LSN: %s | Time: %s&#34;</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>LSN</span>.<span style=color:#a6e22e>String</span>(),
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ServerTime</span>.<span style=color:#a6e22e>Format</span>(<span style=color:#e6db74>&#34;15:04:05&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>SnapshotEventTypeData</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Info</span>(<span style=color:#e6db74>&#34;snapshot message received&#34;</span>, <span style=color:#e6db74>&#34;data&#34;</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Data</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>SnapshotEventTypeEnd</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;ğŸ“¸ SNAPSHOT END | LSN: %s | Time: %s&#34;</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>LSN</span>.<span style=color:#a6e22e>String</span>(),
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ServerTime</span>.<span style=color:#a6e22e>Format</span>(<span style=color:#e6db74>&#34;15:04:05&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>We expose explicit snapshot begin and end markers so that consumers can control how they handle the snapshot window.</p></blockquote><blockquote><p>Note: Snapshot messages are not tied to WAL positions, so <code>ctx.Ack()</code> is a noâ€‘op and always returns nil during snapshot.</p></blockquote><h3 id=monitoring>Monitoring<a hidden class=anchor aria-hidden=true href=#monitoring>#</a></h3><p>There are two metadata tables.</p><ul><li><p><strong>cdc_snapshot_job</strong>: Metadata table for snapshot process tracking
<img alt="CDC Snapshot Job Table" loading=lazy src=/posts/postgre-snapshot/images/cdc_snapshot_job.png></p></li><li><p><strong>cdc_snapshot_chunks</strong>: Each chunk represents work to be done
<img alt="CDC Snapshot Chunks Table" loading=lazy src=/posts/postgre-snapshot/images/cdc_snapshot_chunks.png></p><ul><li><code>chunk_start</code> and <code>chunk_end</code>: Used for <strong>non-numeric</strong> primary keys with <code>LIMIT/OFFSET</code> queries</li><li><code>range_start</code> and <code>range_end</code>: Used for <strong>numeric</strong> primary keys with range-based <code>WHERE</code> clauses for better performance</li></ul><blockquote><p>Range scanning on a numeric PK is not only faster than LIMIT/OFFSET but also avoids performance degradation as the offset grows.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Snapshotter</span>) <span style=color:#a6e22e>buildChunkQuery</span>(<span style=color:#a6e22e>chunk</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Chunk</span>, <span style=color:#a6e22e>orderByClause</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>pkColumns</span> []<span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>chunk</span>.<span style=color:#a6e22e>hasRangeBounds</span>() <span style=color:#f92672>&amp;&amp;</span> len(<span style=color:#a6e22e>pkColumns</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pkColumn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pkColumns</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;SELECT * FROM %s.%s WHERE %s &gt;= %d AND %s &lt;= %d ORDER BY %s LIMIT %d&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>chunk</span>.<span style=color:#a6e22e>TableSchema</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>chunk</span>.<span style=color:#a6e22e>TableName</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>pkColumn</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span><span style=color:#a6e22e>chunk</span>.<span style=color:#a6e22e>RangeStart</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>pkColumn</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span><span style=color:#a6e22e>chunk</span>.<span style=color:#a6e22e>RangeEnd</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>orderByClause</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>chunk</span>.<span style=color:#a6e22e>ChunkSize</span>,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;SELECT * FROM %s.%s ORDER BY %s LIMIT %d OFFSET %d&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>chunk</span>.<span style=color:#a6e22e>TableSchema</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>chunk</span>.<span style=color:#a6e22e>TableName</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>orderByClause</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>chunk</span>.<span style=color:#a6e22e>ChunkSize</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>chunk</span>.<span style=color:#a6e22e>ChunkStart</span>,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>Currently we only use range bounds when there is a single numeric primary key; composite keys fall back to LIMIT/OFFSET chunking.</p></blockquote><ul><li><code>claimed_by</code>: Shows which instance is responsible for that chunk</li><li><code>claimed_at</code>: Shows when the instance was assigned to the chunk</li><li><code>heartbeat_at</code>: Instance heartbeat updates, so we can determine if it&rsquo;s alive or not. If the heartbeat stops, after <code>claimTimeout</code> passes, the chunk is released and a new instance is assigned. You can control this via</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>Snapshot</span>: <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>SnapshotConfig</span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ClaimTimeout</span>:      <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>, <span style=color:#f92672>&lt;--</span> <span style=color:#a6e22e>timeout</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>reclaim</span> <span style=color:#a6e22e>stale</span> <span style=color:#a6e22e>chunks</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>HeartbeatInterval</span>: <span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>, <span style=color:#f92672>&lt;--</span> <span style=color:#a6e22e>heartbeat</span> <span style=color:#a6e22e>at</span> <span style=color:#a6e22e>every</span> <span style=color:#ae81ff>5</span> <span style=color:#a6e22e>sec</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h3 id=how-snapshot-mode-snapshot-only-is-used>How snapshot mode &lsquo;Snapshot Only&rsquo; is used<a hidden class=anchor aria-hidden=true href=#how-snapshot-mode-snapshot-only-is-used>#</a></h3><p>Full example <a href=https://github.com/Trendyol/go-pq-cdc/tree/main/example/snapshot-only-mode>here</a>.</p><p>We have <code>users</code> table. <code>100</code> users exist.</p><h4 id=configuration-2>Configuration<a hidden class=anchor aria-hidden=true href=#configuration-2>#</a></h4><ul><li><strong>Note</strong>: No need to provide slot or publication configuration for snapshot-only mode</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>cfg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// PostgreSQL connection credentials (Host, Port, User, Password, Database)</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Snapshot</span>: <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>SnapshotConfig</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Enabled</span>:           <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Mode</span>:              <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>SnapshotModeSnapshotOnly</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Tables</span>: <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Tables</span>{ <span style=color:#75715e>// --&gt; Snapshot tables</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>Table</span>{
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>Name</span>:            <span style=color:#e6db74>&#34;users&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>ReplicaIdentity</span>: <span style=color:#a6e22e>publication</span>.<span style=color:#a6e22e>ReplicaIdentityDefault</span>,
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>Schema</span>:          <span style=color:#e6db74>&#34;public&#34;</span>,
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        }, 
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ChunkSize</span>:         <span style=color:#ae81ff>100</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ClaimTimeout</span>:      <span style=color:#ae81ff>30</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>HeartbeatInterval</span>: <span style=color:#ae81ff>5</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Metric</span>: <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>MetricConfig</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Port</span>: <span style=color:#ae81ff>8081</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Logger</span>: <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>LoggerConfig</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>LogLevel</span>: <span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>LevelInfo</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>connector</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cdc</span>.<span style=color:#a6e22e>NewConnector</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>cfg</span>, <span style=color:#a6e22e>Handler</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#e6db74>&#34;new connector&#34;</span>, <span style=color:#e6db74>&#34;error&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>connector</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>connector</span>.<span style=color:#a6e22e>Start</span>(<span style=color:#a6e22e>ctx</span>)
</span></span></code></pre></div><h4 id=handler-function-2>Handler Function<a hidden class=anchor aria-hidden=true href=#handler-function-2>#</a></h4><p>Subscribe to snapshot messages by providing a handler function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Handler</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>replication</span>.<span style=color:#a6e22e>ListenerContext</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>msg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Message</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>Snapshot</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>EventType</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>SnapshotEventTypeBegin</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;ğŸ“¸ SNAPSHOT BEGIN | LSN: %s | Time: %s&#34;</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>LSN</span>.<span style=color:#a6e22e>String</span>(),
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>ServerTime</span>.<span style=color:#a6e22e>Format</span>(<span style=color:#e6db74>&#34;15:04:05&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>SnapshotEventTypeData</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>slog</span>.<span style=color:#a6e22e>Info</span>(<span style=color:#e6db74>&#34;snapshot message received&#34;</span>, <span style=color:#e6db74>&#34;data&#34;</span>, <span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>Data</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>format</span>.<span style=color:#a6e22e>SnapshotEventTypeEnd</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;ğŸ“¸ SNAPSHOT END | LSN: %s | Time: %s&#34;</span>,
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>LSN</span>.<span style=color:#a6e22e>String</span>(),
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>ServerTime</span>.<span style=color:#a6e22e>Format</span>(<span style=color:#e6db74>&#34;15:04:05&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=scaling-snapshot-process>Scaling Snapshot Process<a hidden class=anchor aria-hidden=true href=#scaling-snapshot-process>#</a></h3><p>We can easily scale horizontally during the snapshot process.</p><p>Full example <a href=https://github.com/Trendyol/go-pq-cdc/tree/main/example/snapshot-with-scaling>here</a>.</p><p>There is no specific configuration or handling required in the codebase for scaling.</p><p>Let&rsquo;s play with it by scaling to 3 containers <code>docker-compose up --scale go-pq-cdc=3 -d</code></p><p><img alt=instance_1 loading=lazy src=/posts/postgre-snapshot/images/instance-1.png>
<img alt=instance_2 loading=lazy src=/posts/postgre-snapshot/images/instance-2.png>
<img alt=instance_3 loading=lazy src=/posts/postgre-snapshot/images/instance-3.png>
<img alt="chunk status multiple instance" loading=lazy src=/posts/postgre-snapshot/images/chunk-status-multiple-instance.png></p><h2 id=snapshot-architecture-basics-how-it-works-internally>Snapshot Architecture Basics (How It Works Internally)<a hidden class=anchor aria-hidden=true href=#snapshot-architecture-basics-how-it-works-internally>#</a></h2><blockquote><p>The rest of this article explains how we implemented snapshotting under the hood. You donâ€™t need this part to use the feature, but itâ€™s useful if you care about the internals or want to adapt the design.</p></blockquote><p>Before we walk through the snapshot lifecycle, we need to explain a couple of concepts.</p><h3 id=pg_try_advisory_lock>pg_try_advisory_lock()<a hidden class=anchor aria-hidden=true href=#pg_try_advisory_lock>#</a></h3><p><code>pg_try_advisory_lock</code> is a <strong>non-blocking</strong> function in PostgreSQL. It attempts to acquire an application-level lock
using a key you specify. If the lock is already held by another session <em>(in our case instance)</em>, the function returns
<code>FALSE</code> immediately instead of waiting.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>lockID</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hashString</span>(<span style=color:#a6e22e>slotName</span>)  <span style=color:#75715e>// e.g., &#34;cdc_slot&#34; -&gt; 12345</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>acquired</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>SELECT</span> <span style=color:#a6e22e>pg_try_advisory_lock</span>(<span style=color:#a6e22e>lockID</span>)
</span></span></code></pre></div><p>When multiple instances start simultaneously, they need to elect a coordinator:</p><pre tabindex=0><code>Coordinator Election
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚Instance1â”‚â”€â”€pg_try_advisory_lock()â”€â”€â–º Success (Coordinator)
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚Instance2â”‚â”€â”€pg_try_advisory_lock()â”€â”€â–º Fail (Worker)
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚Instance3â”‚â”€â”€pg_try_advisory_lock()â”€â”€â–º Fail (Worker)
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre><blockquote><p>Advisory locks are automatically released when the connection closes.
If you are using PgBouncer, prefer transaction pooling mode here; session mode may cause surprising behavior with advisory locks because connections are reused across sessions.</p></blockquote><h3 id=repeatable-read-isolation-level>Repeatable Read Isolation Level<a hidden class=anchor aria-hidden=true href=#repeatable-read-isolation-level>#</a></h3><p>The <code>Repeatable Read</code> isolation level guarantees that any rows a transaction reads will remain unchanged for
the duration of that transaction, preventing non-repeatable reads. Let&rsquo;s examine it with an example.</p><pre tabindex=0><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Time   â”‚  Transaction A (Repeatable Read)    â”‚  Transaction B (Normal)             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    T1    â”‚  BEGIN TRANSACTION ISOLATION        â”‚                                     â”‚
â”‚          â”‚  LEVEL REPEATABLE READ;             â”‚                                     â”‚
â”‚          â”‚  â†’ Takes snapshot of data           â”‚                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    T2    â”‚  SELECT balance FROM Accounts       â”‚                                     â”‚
â”‚          â”‚  WHERE AccountID = 1;               â”‚                                     â”‚
â”‚          â”‚  â†’ Result: 500 â‚º                    â”‚                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    T3    â”‚                                     â”‚  BEGIN TRANSACTION;                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    T4    â”‚                                     â”‚  UPDATE Accounts SET balance = 400  â”‚
â”‚          â”‚                                     â”‚  WHERE AccountID = 1;               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    T5    â”‚                                     â”‚  COMMIT; âœ“                          â”‚
â”‚          â”‚                                     â”‚  â†’ 400 â‚º is now permanent           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    T6    â”‚  SELECT balance FROM Accounts       â”‚                                     â”‚
â”‚          â”‚  WHERE AccountID = 1;               â”‚                                     â”‚
â”‚          â”‚  â†’ Result: 500 â‚º (still!)           â”‚                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    T7    â”‚  COMMIT;                            â”‚                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre><p><strong>Key Point</strong>: Transaction A always reads from the data <strong>as it was at T1</strong>, regardless of B&rsquo;s commit at T5. This is how we ensure all instances read a consistent, frozen view of the data during the entire snapshot.</p><p>In our library, the coordinator exports a PostgreSQL snapshot and keeps it open during the snapshot process:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 1. Start transaction (REPEATABLE READ for consistency)</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>BEGIN</span> <span style=color:#a6e22e>TRANSACTION</span> <span style=color:#a6e22e>ISOLATION</span> <span style=color:#a6e22e>LEVEL</span> <span style=color:#a6e22e>REPEATABLE</span> <span style=color:#a6e22e>READ</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2. Export snapshot</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>snapshotID</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>SELECT</span> <span style=color:#a6e22e>pg_export_snapshot</span>()  
</span></span><span style=display:flex><span><span style=color:#75715e>// Returns: &#34;00000003-00000002-1&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 3. Keep transaction OPEN!</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// (Do NOT commit/rollback yet)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 4. Update job metadata</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>UPDATE</span> <span style=color:#a6e22e>cdc_snapshot_job</span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>SET</span> <span style=color:#a6e22e>snapshot_id</span> = <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#ae81ff>00000003</span><span style=color:#f92672>-</span><span style=color:#ae81ff>00000002</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#960050;background-color:#1e0010>&#39;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>WHERE</span> <span style=color:#a6e22e>slot_name</span> = <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#a6e22e>cdc_slot</span><span style=color:#960050;background-color:#1e0010>&#39;</span>
</span></span></code></pre></div><p><strong>Why?</strong> Because when we are using multiple instances, we need to ensure that all instances see same snapshot of the data.</p><p>By exporting the coordinator transactionâ€™s snapshot using <code>pg_export_snapshot()</code>, workers can read this value from <code>cdc_snapshot_job</code>
and set their own transactions to it, so we provide transactional consistency.</p><pre tabindex=0><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Coordinator Transaction (REPEATABLE READ)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ BEGIN                                               â”‚    â”‚
â”‚  â”‚ SELECT pg_export_snapshot() â†’ &#39;snapshot_123&#39;       â”‚    â”‚
â”‚  â”‚ ... (transaction stays open) ...                   â”‚    â”‚
â”‚  â”‚                                                     â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚
â”‚  â”‚  â”‚ Worker 1: SET TRANSACTION SNAPSHOT &#39;snap123&#39; â”‚ â”‚    â”‚
â”‚  â”‚  â”‚ SELECT * FROM users ... (sees same data!)    â”‚ â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚
â”‚  â”‚                                                     â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚
â”‚  â”‚  â”‚ Worker 2: SET TRANSACTION SNAPSHOT &#39;snap123&#39; â”‚ â”‚    â”‚
â”‚  â”‚  â”‚ SELECT * FROM orders ... (sees same data!)   â”‚ â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚
â”‚  â”‚                                                     â”‚    â”‚
â”‚  â”‚ COMMIT (after all chunks done)                     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

If coordinator closed transaction early:
  âŒ Snapshot ID becomes invalid
  âŒ Workers can&#39;t use SET TRANSACTION SNAPSHOT
  âŒ Data inconsistency across chunks
  âŒ All snapshot process is aborted. It will start to take new snapshot!
</code></pre><blockquote><p>Because the coordinator holds a longâ€‘running REPEATABLE READ transaction, old row versions must be kept until the
snapshot finishes. For most initialâ€‘load scenarios this is acceptable, but you should be aware of the potential
for extra bloat while a long snapshot is running.</p></blockquote><h3 id=how-we-ensure-no-data-is-missed>How We Ensure No Data Is Missed<a hidden class=anchor aria-hidden=true href=#how-we-ensure-no-data-is-missed>#</a></h3><p>How do we ensure no data is missed between snapshot and CDC process?</p><p>Before starting the snapshot, we capture the current LSN with <code>pg_current_wal_lsn()</code>.</p><p>The single value returned by <code>SELECT pg_current_wal_lsn()</code> represents the absolute location of the last point the primary server has written to the Write-Ahead Log (WAL).</p><p>We use this value as the starting LSN when we start the replication slot stream:</p><p><code>START_REPLICATION SLOT cdc_slot LOGICAL 0/12345678</code></p><pre tabindex=0><code>Timeline:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
         â”‚                    â”‚                    â”‚
         T0                   T1                   T2
    Snapshot LSN         Snapshot End         Current Time
    (0/12345678)
         â”‚                    â”‚                    â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
         â”‚   Snapshot Data    â”‚    CDC Data        â”‚
         â”‚   (goes to handler)â”‚  (goes to handler) â”‚
         â”‚                    â”‚                    â”‚
         â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”‚
         No overlap!    CDC starts from snapshot LSN
</code></pre><p>Simply, all rows selected during snapshot are guaranteed to be visible as of the snapshotâ€™s MVCC view; any later changes will appear as logical replication events after we start CDC at the stored LSN.</p><h2 id=snapshot-lifecycle>Snapshot Lifecycle<a hidden class=anchor aria-hidden=true href=#snapshot-lifecycle>#</a></h2><p>The snapshot process consists of 5 phases:</p><h3 id=phase-1-coordinator-election>Phase 1: Coordinator Election<a hidden class=anchor aria-hidden=true href=#phase-1-coordinator-election>#</a></h3><pre tabindex=0><code>Instance1 â”€â”€pg_try_advisory_lock()â”€â”€â–º Success (Coordinator) âœ“
Instance2 â”€â”€pg_try_advisory_lock()â”€â”€â–º Fail (Worker)
Instance3 â”€â”€pg_try_advisory_lock()â”€â”€â–º Fail (Worker)
</code></pre><p>Only one instance becomes the coordinator. Others become workers.</p><h3 id=phase-2-metadata-creation-coordinator-only>Phase 2: Metadata Creation (Coordinator Only)<a hidden class=anchor aria-hidden=true href=#phase-2-metadata-creation-coordinator-only>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- Capture current LSN
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>SELECT</span> pg_current_wal_lsn(); <span style=color:#75715e>-- â†’ 0/12345678
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Create job metadata  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> cdc_snapshot_job (...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Split tables into chunks
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- Table &#34;users&#34;: 1M rows â†’ 10 chunks (100K each)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> cdc_snapshot_chunks (...);
</span></span></code></pre></div><h3 id=phase-3-snapshot-export-coordinator-only>Phase 3: Snapshot Export (Coordinator Only)<a hidden class=anchor aria-hidden=true href=#phase-3-snapshot-export-coordinator-only>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>BEGIN</span> <span style=color:#66d9ef>TRANSACTION</span> <span style=color:#66d9ef>ISOLATION</span> <span style=color:#66d9ef>LEVEL</span> <span style=color:#66d9ef>REPEATABLE</span> <span style=color:#66d9ef>READ</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> pg_export_snapshot(); <span style=color:#75715e>-- â†’ &#34;00000003-00000002-1&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- Keep transaction OPEN! (critical)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>UPDATE</span> cdc_snapshot_job <span style=color:#66d9ef>SET</span> snapshot_id <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;00000003-00000002-1&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>-- Workers can now join using this snapshot_id
</span></span></span></code></pre></div><p>After that, the coordinator simply acts as another worker.</p><h3 id=phase-4-chunk-processing-all-instances-in-parallel>Phase 4: Chunk Processing (All Instances in Parallel)<a hidden class=anchor aria-hidden=true href=#phase-4-chunk-processing-all-instances-in-parallel>#</a></h3><pre tabindex=0><code>Worker Loop:
â”Œâ”€â–º Claim next chunk (SELECT FOR UPDATE SKIP LOCKED)
â”‚   â”œâ”€â–º BEGIN TRANSACTION
â”‚   â”œâ”€â–º SET TRANSACTION SNAPSHOT &#39;snapshot_id&#39;
â”‚   â”œâ”€â–º SELECT * FROM table WHERE id &gt;= X AND id &lt;= Y
â”‚   â”œâ”€â–º Send DATA events to handler
â”‚   â”œâ”€â–º COMMIT
â”‚   â”œâ”€â–º Mark chunk completed
â””â”€â”€â”€â”´â”€â”€ Repeat until no chunks left
</code></pre><h3 id=phase-5-cdc-continuation>Phase 5: CDC Continuation<a hidden class=anchor aria-hidden=true href=#phase-5-cdc-continuation>#</a></h3><ul><li>All chunks completed â†’ Snapshot transaction closed</li><li>CDC starts from snapshot LSN (<code>START_REPLICATION SLOT ... LOGICAL 0/12345678</code>)</li><li><strong>No duplicate data!</strong> Snapshot ends where CDC begins.</li></ul><h3 id=crash-recovery>Crash Recovery<a hidden class=anchor aria-hidden=true href=#crash-recovery>#</a></h3><p>What happens if an instance crashes during snapshot?</p><p><strong>Worker Crash</strong>: The chunk being processed becomes &ldquo;stale&rdquo; after <code>claimTimeout</code> (e.g., 30s). Another instance automatically reclaims and reprocesses it.</p><pre tabindex=0><code>Before Crash:
  C0: completed âœ“    C3: pending
  C1: completed âœ“    C4: pending  
  C2: in_progress â† crashed here

After Restart (30s later):
  C2 becomes stale â†’ reclaimed by healthy instance
</code></pre><p><strong>Coordinator Crash Before Export</strong>: Incomplete job is detected on restart. The system cleans up and <strong>restarts snapshot from scratch</strong>.</p><p>When a worker (or a new instance) comes back, processing resumes from where it left off â€” completed chunks are skipped, pending chunks are processed.</p><hr><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>The Snapshot Feature provides a robust, scalable solution for initial data capture:</p><ul><li>âœ… <strong>Zero Data Loss</strong>: Consistent snapshot + CDC continuation</li><li>âœ… <strong>Scalable</strong>: Chunk-based, multi-instance parallel processing</li><li>âœ… <strong>Resilient</strong>: Automatic crash recovery</li><li>âœ… <strong>Observable</strong>: Metadata tables for progress tracking</li></ul><p>For more details, check out the <a href=https://github.com/Trendyol/go-pq-cdc>go-pq-cdc repository</a>.</p><blockquote><p>Thank you for reading!</p></blockquote><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://abdulsametileri.github.io/tags/go/>Go</a></li><li><a href=https://abdulsametileri.github.io/tags/postgresql/>Postgresql</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share How We Implement Debezium Style Initial Data (Snapshot) Progress in Our PostgreSQL CDC Library on x" href="https://x.com/intent/tweet/?text=How%20We%20Implement%20Debezium%20Style%20Initial%20Data%20%28Snapshot%29%20Progress%20in%20Our%20PostgreSQL%20CDC%20Library&amp;url=https%3a%2f%2fabdulsametileri.github.io%2fposts%2fpostgre-snapshot%2f&amp;hashtags=go%2cpostgresql"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share How We Implement Debezium Style Initial Data (Snapshot) Progress in Our PostgreSQL CDC Library on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fabdulsametileri.github.io%2fposts%2fpostgre-snapshot%2f&amp;title=How%20We%20Implement%20Debezium%20Style%20Initial%20Data%20%28Snapshot%29%20Progress%20in%20Our%20PostgreSQL%20CDC%20Library&amp;summary=How%20We%20Implement%20Debezium%20Style%20Initial%20Data%20%28Snapshot%29%20Progress%20in%20Our%20PostgreSQL%20CDC%20Library&amp;source=https%3a%2f%2fabdulsametileri.github.io%2fposts%2fpostgre-snapshot%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://abdulsametileri.github.io/>Abdulsamet's Blog</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>